/**
 * üîç FINAL SYSTEM ANALYSIS - Production Ready Checker
 * Comprehensive analysis tool for deployment readiness
 */

const fs = require('fs').promises;
const path = require('path');

class FinalSystemAnalyzer {
  constructor() {
    this.startTime = Date.now();
    this.results = {
      fileStructure: {},
      codeQuality: {},
      functionality: {},
      production: {},
      security: {},
      performance: {},
      userInterface: {},
      overall: {}
    };
  }

  async runFinalAnalysis() {
    console.log('üîç HAYDAY CHAT SYSTEM - FINAL PRODUCTION ANALYSIS');
    console.log('‚ïê'.repeat(65));
    console.log('‚è∞ Analysis Time:', new Date().toLocaleString('tr-TR'));
    console.log('üéØ Target: 97%+ Production Ready Score');
    console.log('');
    
    try {
      await this.analyzeFileStructure();
      await this.analyzeCodeQuality(); 
      await this.analyzeFunctionality();
      await this.analyzeProductionReadiness();
      await this.analyzeSecurity();
      await this.analyzePerformance();
      await this.analyzeUserInterface();
      
      this.generateFinalReport();
      return this.results;
    } catch (error) {
      console.error('‚ùå Analysis failed:', error);
      return null;
    }
  }

  async analyzeFileStructure() {
    console.log('üìÅ File Structure Analysis...');
    
    const criticalFiles = {
      core: ['package.json', 'server.js', 'render.yaml', '.env.example'],
      frontend: ['index.html', 'admin.html', 'login.html', 'style.css', 'script.js'],
      data: ['chat-log.json', 'knowledge-base.json', 'analytics.json', 'admin-sessions.json'],
      assets: ['assets/js/chat-loader.js', 'assets/js/ai-brain.js', 'assets/js/telegram-bot.js', 'assets/js/utils.js'],
      tools: ['fix-html-encoding.js', 'system-analysis.js', 'utf8-test.js', 'utf8-fix.js'],
      docs: ['README.md', 'PRODUCTION-READY-CHECKLIST.md', '.gitignore']
    };

    let totalRequired = 0;
    let foundFiles = 0;
    const categoryResults = {};

    for (const [category, files] of Object.entries(criticalFiles)) {
      let categoryFound = 0;
      
      for (const file of files) {
        totalRequired++;
        try {
          const stats = await fs.stat(file);
          foundFiles++;
          categoryFound++;
          console.log(`‚úÖ ${file} (${this.formatSize(stats.size)})`);
        } catch {
          console.log(`‚ùå ${file} - MISSING`);
        }
      }
      
      categoryResults[category] = {
        required: files.length,
        found: categoryFound,
        percentage: Math.round((categoryFound / files.length) * 100)
      };
    }

    this.results.fileStructure = {
      totalRequired,
      foundFiles,
      completeness: Math.round((foundFiles / totalRequired) * 100),
      categories: categoryResults
    };

    console.log(`üìä File Completeness: ${this.results.fileStructure.completeness}% (${foundFiles}/${totalRequired})\n`);
  }

  async analyzeCodeQuality() {
    console.log('üîß Code Quality Analysis...');
    
    const codeFiles = [
      'server.js', 'script.js', 'assets/js/chat-loader.js',
      'assets/js/ai-brain.js', 'assets/js/utils.js'
    ];

    let totalLines = 0;
    let qualityFiles = 0;
    let utf8Issues = 0;
    let errorHandling = 0;
    const fileDetails = {};

    for (const file of codeFiles) {
      try {
        const content = await fs.readFile(file, 'utf8');
        const lines = content.split('\n').length;
        totalLines += lines;

        const analysis = {
          lines,
          hasContent: lines > 20,
          hasUTF8Issues: this.hasEncodingIssues(content),
          hasErrorHandling: this.hasErrorHandling(content),
          hasDocumentation: this.hasDocumentation(content)
        };

        fileDetails[file] = analysis;

        if (analysis.hasContent) qualityFiles++;
        if (analysis.hasUTF8Issues) utf8Issues++;
        if (analysis.hasErrorHandling) errorHandling++;

        const status = analysis.hasContent && !analysis.hasUTF8Issues ? '‚úÖ' : '‚ö†Ô∏è';
        const issues = [];
        if (analysis.hasUTF8Issues) issues.push('UTF-8');
        if (!analysis.hasErrorHandling) issues.push('Error handling');
        
        console.log(`${status} ${file} - ${lines} lines${issues.length ? ` (${issues.join(', ')})` : ''}`);

      } catch (error) {
        console.log(`‚ùå ${file} - Read error: ${error.message}`);
        fileDetails[file] = { error: error.message };
      }
    }

    this.results.codeQuality = {
      totalLines,
      qualityFiles,
      utf8Issues,
      errorHandling,
      score: Math.round(((qualityFiles * 2 + errorHandling - utf8Issues) / (codeFiles.length * 2.5)) * 100),
      details: fileDetails
    };

    console.log(`üìä Code Quality Score: ${this.results.codeQuality.score}%\n`);
  }

  async analyzeFunctionality() {
    console.log('‚öôÔ∏è Functionality Analysis...');
    
    const features = {
      'ChatBot System': await this.checkChatBotSystem(),
      'AI Integration': await this.checkAIIntegration(),
      'Telegram Bot': await this.checkTelegramBot(),
      'Admin Panel': await this.checkAdminPanel(),
      'Real-time Polling': await this.checkRealTimeFeatures(),
      'Mobile Support': await this.checkMobileSupport(),
      'Cross-page Continuity': await this.checkContinuity(),
      'UTF-8 Support': await this.checkUTF8Support(),
      'File Management': await this.checkFileManagement(),
      'Health Monitoring': await this.checkHealthMonitoring()
    };

    let implementedFeatures = 0;
    for (const [feature, implemented] of Object.entries(features)) {
      const status = implemented ? '‚úÖ' : '‚ùå';
      console.log(`${status} ${feature}`);
      if (implemented) implementedFeatures++;
    }

    this.results.functionality = {
      features,
      implemented: implementedFeatures,
      total: Object.keys(features).length,
      percentage: Math.round((implementedFeatures / Object.keys(features).length) * 100)
    };

    console.log(`üìä Functionality Score: ${this.results.functionality.percentage}%\n`);
  }

  async analyzeProductionReadiness() {
    console.log('üöÄ Production Readiness Analysis...');
    
    const checks = {
      'Environment Setup': await this.checkEnvironmentSetup(),
      'Render Config': await this.checkRenderConfig(),
      'Health Endpoints': await this.checkHealthEndpoints(),
      'Error Handling': await this.checkGlobalErrorHandling(),
      'Logging System': await this.checkLoggingSystem(),
      'Graceful Shutdown': await this.checkGracefulShutdown(),
      'File Backup': await this.checkBackupSystem(),
      'Deployment Ready': await this.checkDeploymentReady()
    };

    let readyFeatures = 0;
    for (const [feature, ready] of Object.entries(checks)) {
      const status = ready ? '‚úÖ' : '‚ùå';
      console.log(`${status} ${feature}`);
      if (ready) readyFeatures++;
    }

    this.results.production = {
      checks,
      readyFeatures,
      totalChecks: Object.keys(checks).length,
      readiness: Math.round((readyFeatures / Object.keys(checks).length) * 100)
    };

    console.log(`üìä Production Score: ${this.results.production.readiness}%\n`);
  }

  async analyzeSecurity() {
    console.log('üîí Security Analysis...');
    
    const securityChecks = {
      'Input Validation': await this.checkInputValidation(),
      'Rate Limiting': await this.checkRateLimiting(),
      'CORS Configuration': await this.checkCORSConfig(),
      'Helmet Security': await this.checkHelmetSecurity(),
      'Admin Authentication': await this.checkAdminAuth(),
      'Session Management': await this.checkSessionManagement(),
      'XSS Protection': await this.checkXSSProtection(),
      'API Security': await this.checkAPISecurity()
    };

    let secureFeatures = 0;
    for (const [feature, secure] of Object.entries(securityChecks)) {
      const status = secure ? '‚úÖ' : '‚ö†Ô∏è';
      console.log(`${status} ${feature}`);
      if (secure) secureFeatures++;
    }

    this.results.security = {
      checks: securityChecks,
      secureFeatures,
      totalChecks: Object.keys(securityChecks).length,
      score: Math.round((secureFeatures / Object.keys(securityChecks).length) * 100)
    };

    console.log(`üìä Security Score: ${this.results.security.score}%\n`);
  }

  async analyzePerformance() {
    console.log('‚ö° Performance Analysis...');
    
    const perfChecks = {
      'File Locking': await this.checkFileLocking(),
      'Memory Management': await this.checkMemoryManagement(),
      'Database Optimization': await this.checkDatabaseOpt(),
      'Frontend Optimization': await this.checkFrontendOpt(),
      'Caching Strategy': await this.checkCaching(),
      'Resource Management': await this.checkResourceManagement()
    };

    let optimizedFeatures = 0;
    for (const [feature, optimized] of Object.entries(perfChecks)) {
      const status = optimized ? '‚úÖ' : '‚ö†Ô∏è';
      console.log(`${status} ${feature}`);
      if (optimized) optimizedFeatures++;
    }

    this.results.performance = {
      checks: perfChecks,
      optimizedFeatures,
      totalChecks: Object.keys(perfChecks).length,
      score: Math.round((optimizedFeatures / Object.keys(perfChecks).length) * 100)
    };

    console.log(`üìä Performance Score: ${this.results.performance.score}%\n`);
  }

  async analyzeUserInterface() {
    console.log('üé® User Interface Analysis...');
    
    const uiChecks = {
      'HTML UTF-8 Fixed': await this.checkHTMLUTF8(),
      'Mobile Responsive': await this.checkMobileResponsive(), 
      'Accessibility': await this.checkAccessibility(),
      'CSS Optimization': await this.checkCSSOptimization(),
      'Cross-browser Compat': await this.checkCrossBrowser(),
      'UI Consistency': await this.checkUIConsistency()
    };

    let uiFeatures = 0;
    for (const [feature, working] of Object.entries(uiChecks)) {
      const status = working ? '‚úÖ' : '‚ùå';
      console.log(`${status} ${feature}`);
      if (working) uiFeatures++;
    }

    this.results.userInterface = {
      checks: uiChecks,
      workingFeatures: uiFeatures,
      totalChecks: Object.keys(uiChecks).length,
      score: Math.round((uiFeatures / Object.keys(uiChecks).length) * 100)
    };

    console.log(`üìä UI/UX Score: ${this.results.userInterface.score}%\n`);
  }

  // Helper check methods
  async checkChatBotSystem() {
    try {
      const serverContent = await fs.readFile('server.js', 'utf8');
      const knowledgeExists = await fs.access('knowledge-base.json').then(() => true).catch(() => false);
      return serverContent.includes('ChatBotBrain') && knowledgeExists;
    } catch { return false; }
  }

  async checkAIIntegration() {
    try {
      const serverContent = await fs.readFile('server.js', 'utf8');
      return serverContent.includes('OpenAI') && serverContent.includes('gpt-3.5-turbo');
    } catch { return false; }
  }

  async checkTelegramBot() {
    try {
      const serverContent = await fs.readFile('server.js', 'utf8');
      return serverContent.includes('TelegramBot') && serverContent.includes('webhook');
    } catch { return false; }
  }

  async checkAdminPanel() {
    try {
      await fs.access('admin.html');
      await fs.access('login.html');
      return true;
    } catch { return false; }
  }

  async checkRealTimeFeatures() {
    try {
      const serverContent = await fs.readFile('server.js', 'utf8');
      return serverContent.includes('/api/chat/poll');
    } catch { return false; }
  }

  async checkMobileSupport() {
    try {
      const cssContent = await fs.readFile('style.css', 'utf8');
      return cssContent.includes('@media') && cssContent.includes('mobile');
    } catch { return false; }
  }

  async checkContinuity() {
    try {
      const scriptContent = await fs.readFile('script.js', 'utf8');
      return scriptContent.includes('localStorage') && scriptContent.includes('clientId');
    } catch { return false; }
  }

  async checkUTF8Support() {
    try {
      const serverContent = await fs.readFile('server.js', 'utf8');
      return serverContent.includes('charset=utf-8');
    } catch { return false; }
  }

  async checkFileManagement() {
    try {
      const serverContent = await fs.readFile('server.js', 'utf8');
      return serverContent.includes('FileManager') && serverContent.includes('FileLock');
    } catch { return false; }
  }

  async checkHealthMonitoring() {
    try {
      const serverContent = await fs.readFile('server.js', 'utf8');
      return serverContent.includes('/ping');
    } catch { return false; }
  }

  async checkHTMLUTF8() {
    try {
      const htmlFiles = ['index.html', 'admin.html', 'login.html'];
      for (const file of htmlFiles) {
        const content = await fs.readFile(file, 'utf8');
        if (this.hasEncodingIssues(content)) {
          return false;
        }
      }
      return true;
    } catch { return false; }
  }

  hasEncodingIssues(content) {
    const issues = ['√∞≈∏¬§‚Äì', '√∞≈∏"¬§', '√∞≈∏"', '√É‚Ä°evrimi√É¬ßi', 'nas√Ñ¬±l', '√¢≈ì‚Ä¢', '√¢¬≥'];
    return issues.some(issue => content.includes(issue));
  }

  hasErrorHandling(content) {
    return content.includes('try {') && content.includes('catch');
  }

  hasDocumentation(content) {
    return content.includes('/**') || content.includes('//');
  }

  formatSize(bytes) {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  }

  generateFinalReport() {
    const duration = Date.now() - this.startTime;
    
    console.log('‚ïê'.repeat(65));
    console.log('üìä HAYDAY CHAT SYSTEM - FINAL PRODUCTION REPORT');
    console.log('‚ïê'.repeat(65));
    
    // Calculate overall score
    const scores = [
      this.results.fileStructure.completeness,
      this.results.codeQuality.score,
      this.results.functionality.percentage,
      this.results.production.readiness,
      this.results.security.score,
      this.results.performance.score,
      this.results.userInterface.score
    ];
    
    const overallScore = Math.round(scores.reduce((a, b) => a + b) / scores.length);
    this.results.overall.score = overallScore;
    
    console.log(`\nüéØ OVERALL PRODUCTION SCORE: ${overallScore}%`);
    console.log(this.getProductionStatus(overallScore));
    
    console.log('\nüìã COMPONENT BREAKDOWN:');
    console.log(`üìÅ File Structure: ${this.results.fileStructure.completeness}% (${this.results.fileStructure.foundFiles}/${this.results.fileStructure.totalRequired} files)`);
    console.log(`üîß Code Quality: ${this.results.codeQuality.score}% (${this.results.codeQuality.totalLines} lines)`);
    console.log(`‚öôÔ∏è Functionality: ${this.results.functionality.percentage}% (${this.results.functionality.implemented}/${this.results.functionality.total} features)`);
    console.log(`üöÄ Production: ${this.results.production.readiness}% (${this.results.production.readyFeatures}/${this.results.production.totalChecks} checks)`);
    console.log(`üîí Security: ${this.results.security.score}% (${this.results.security.secureFeatures}/${this.results.security.totalChecks} measures)`);
    console.log(`‚ö° Performance: ${this.results.performance.score}% (${this.results.performance.optimizedFeatures}/${this.results.performance.totalChecks} optimizations)`);
    console.log(`üé® UI/UX: ${this.results.userInterface.score}% (${this.results.userInterface.workingFeatures}/${this.results.userInterface.totalChecks} features)`);

    console.log('\nüéä DEPLOYMENT STATUS:');
    this.printDeploymentStatus(overallScore);

    console.log('\nüí° FINAL RECOMMENDATIONS:');
    this.printFinalRecommendations(overallScore);

    console.log('\nüèÅ ANALYSIS COMPLETED!');
    console.log(`‚è±Ô∏è Duration: ${duration}ms`);
    console.log(`üìÖ Completed: ${new Date().toLocaleString('tr-TR')}`);
    console.log('‚ïê'.repeat(65));
  }

  getProductionStatus(score) {
    if (score >= 97) return 'üèÜ PRODUCTION EXCELLENCE - Deploy immediately!';
    if (score >= 93) return 'ü•á PRODUCTION READY - Excellent quality!';
    if (score >= 90) return 'ü•à PRODUCTION READY - Good to deploy!';
    if (score >= 85) return 'ü•â NEAR PRODUCTION - Minor fixes needed';
    if (score >= 80) return '‚ö†Ô∏è NEEDS WORK - Several issues to resolve';
    return 'üö® NOT READY - Major development required';
  }

  printDeploymentStatus(score) {
    if (score >= 90) {
      console.log('üü¢ DEPLOY APPROVED!');
      console.log('‚úÖ All critical systems operational');
      console.log('‚úÖ Performance metrics excellent');
      console.log('‚úÖ Security measures in place');
      console.log('‚úÖ User experience optimized');
      console.log('');
      console.log('üöÄ DEPLOYMENT COMMANDS:');
      console.log('git add .');
      console.log('git commit -m "üöÄ Production ready - All systems go!"');
      console.log('git push origin main');
    } else if (score >= 85) {
      console.log('üü° DEPLOY WITH CAUTION');
      console.log('‚ö†Ô∏è Minor issues should be addressed');
      console.log('‚úÖ Core functionality working');
    } else {
      console.log('üî¥ DEPLOY NOT RECOMMENDED');
      console.log('‚ùå Critical issues need resolution');
      console.log('‚ö†Ô∏è More development required');
    }
  }

  printFinalRecommendations(score) {
    const recommendations = [];
    
    if (this.results.fileStructure.completeness < 100) {
      recommendations.push(`Complete missing files (${100 - this.results.fileStructure.completeness}% remaining)`);
    }
    
    if (this.results.userInterface.score < 90) {
      recommendations.push('Fix UI/UX issues (especially UTF-8 encoding)');
    }
    
    if (this.results.security.score < 90) {
      recommendations.push('Strengthen security measures');
    }
    
    if (score >= 97) {
      recommendations.push('üéâ System is PERFECT! Ready for enterprise deployment!');
    } else if (score >= 90) {
      recommendations.push('System is production-ready with excellent quality');
      recommendations.push('Consider UptimeRobot monitoring setup');
    }
    
    if (recommendations.length === 0) {
      recommendations.push('No critical recommendations - system is optimized! üéä');
    }
    
    recommendations.forEach(rec => console.log(`üí° ${rec}`));
  }

  // Simplified check methods for brevity
  async checkEnvironmentSetup() { return this.fileExists('.env.example'); }
  async checkRenderConfig() { return this.fileExists('render.yaml'); }
  async checkHealthEndpoints() { return this.hasInFile('server.js', '/ping'); }
  async checkGlobalErrorHandling() { return this.hasInFile('server.js', 'process.on'); }
  async checkLoggingSystem() { return this.hasInFile('server.js', 'Logger'); }
  async checkGracefulShutdown() { return this.hasInFile('server.js', 'SIGTERM'); }
  async checkBackupSystem() { return this.hasInFile('server.js', 'backup'); }
  async checkDeploymentReady() { return this.fileExists('package.json') && this.fileExists('render.yaml'); }
  async checkInputValidation() { return this.hasInFile('server.js', 'validationResult'); }
  async checkRateLimiting() { return this.hasInFile('server.js', 'rateLimit'); }
  async checkCORSConfig() { return this.hasInFile('server.js', 'cors'); }
  async checkHelmetSecurity() { return this.hasInFile('server.js', 'helmet'); }
  async checkAdminAuth() { return this.hasInFile('server.js', 'authenticateAdmin'); }
  async checkSessionManagement() { return this.hasInFile('server.js', 'adminSessions'); }
  async checkXSSProtection() { return this.hasInFile('script.js', 'sanitize'); }
  async checkAPISecurity() { return this.hasInFile('server.js', 'Bearer'); }
  async checkFileLocking() { return this.hasInFile('server.js', 'FileLock'); }
  async checkMemoryManagement() { return this.hasInFile('server.js', 'memoryUsage'); }
  async checkDatabaseOpt() { return this.hasInFile('server.js', 'atomic'); }
  async checkFrontendOpt() { return this.hasInFile('style.css', 'transition'); }
  async checkCaching() { return this.hasInFile('script.js', 'localStorage'); }
  async checkResourceManagement() { return this.hasInFile('server.js', 'cleanup'); }
  async checkMobileResponsive() { return this.hasInFile('style.css', '@media'); }
  async checkAccessibility() { return this.hasInFile('index.html', 'aria-'); }
  async checkCSSOptimization() { return this.hasInFile('style.css', ':root'); }
  async checkCrossBrowser() { return this.hasInFile('script.js', 'addEventListener'); }
  async checkUIConsistency() { return this.hasInFile('style.css', '--primary'); }

  async fileExists(file) {
    try {
      await fs.access(file);
      return true;
    } catch {
      return false;
    }
  }

  async hasInFile(file, searchTerm) {
    try {
      const content = await fs.readFile(file, 'utf8');
      return content.includes(searchTerm);
    } catch {
      return false;
    }
  }
}

// CLI Usage
if (require.main === module) {
  const analyzer = new FinalSystemAnalyzer();
  analyzer.runFinalAnalysis().catch(console.error);
}

module.exports = FinalSystemAnalyzer;
    } catch {
      return false;
    }
  }

  async checkDatabaseOpt() {
    try {
      const serverContent = await fs.readFile('server.js', 'utf8');
      return serverContent.includes('atomic') && 
             serverContent.includes('writeJSONFile');
    } catch {
      return false;
    }
  }

  async checkFrontendOpt() {
    try {
      const cssContent = await fs.readFile('style.css', 'utf8');
      const indexContent = await fs.readFile('index.html', 'utf8');
      return cssContent.includes('transition') && 
             indexContent.includes('defer');
    } catch {
      return false;
    }
  }

  async checkCaching() {
    try {
      const serverContent = await fs.readFile('server.js', 'utf8');
      return serverContent.includes('cache') || 
             serverContent.includes('localStorage');
    } catch {
      return false;
    }
  }

  async checkCompression() {
    try {
      const serverContent = await fs.readFile('server.js', 'utf8');
      return serverContent.includes('compression') && 
             serverContent.includes('br');
    } catch {
      return false;
    }
  }

  async checkPackageJson() {
    try {
      const packageContent = await fs.readFile('package.json', 'utf8');
      const packageJson = JSON.parse(packageContent);
      return packageJson.dependencies && packageJson.devDependencies;
    } catch {
      return false;
    }
  }

  async checkEnvTemplate() {
    try {
      const envContent = await fs.readFile('.env.example', 'utf8');
      return envContent.includes('OPENAI_API_KEY') && 
             envContent.includes('TELEGRAM_BOT_TOKEN');
    } catch {
      return false;
    }
  }

  async checkGitIgnore() {
    try {
      const gitignoreContent = await fs.readFile('.gitignore', 'utf8');
      return gitignoreContent.includes('node_modules') && 
             gitignoreContent.includes('.env');
    } catch {
      return false;
    }
  }

  async checkDocumentation() {
    try {
      const readmeContent = await fs.readFile('README.md', 'utf8');
      return readmeContent.includes('## Proje Ba≈ülangƒ±cƒ±') && 
             readmeContent.includes('## Kurulum');
    } catch {
      return false;
    }
  }

  async checkHealthEndpoint() {
    try {
      const serverContent = await fs.readFile('server.js', 'utf8');
      return serverContent.includes('/health') && 
             serverContent.includes('status: "UP"');
    } catch {
      return false;
    }
  }

  generateComprehensiveReport() {
    const duration = Date.now() - this.startTime;
    
    console.log('‚ïê'.repeat(60));
    console.log('üìä HAYDAY CHAT SYSTEM - KAPSAMLI ANALƒ∞Z RAPORU');
    console.log('‚ïê'.repeat(60));
    
    // Overall Score Calculation
    const scores = [
      this.results.fileStructure.completeness,
      this.results.codeQuality.score,
      this.results.functionality.percentage,
      this.results.production.readiness,
      this.results.security.score,
      this.results.performance.score,
      this.results.deployment.readiness
    ];
    
    const overallScore = Math.round(scores.reduce((a, b) => a + b) / scores.length);
    
    console.log(`\nüéØ GENEL SKOR: ${overallScore}%`);
    console.log(this.getScoreStatus(overallScore));
    
    console.log('\nüìã DETAYLI SONU√áLAR:');
    console.log(`üìÅ Dosya Yapƒ±sƒ±: ${this.results.fileStructure.completeness}% (${this.results.fileStructure.found}/${this.results.fileStructure.totalRequired})`);
    console.log(`üîß Kod Kalitesi: ${this.results.codeQuality.score}% (${this.results.codeQuality.totalLines} satƒ±r)`);
    console.log(`‚öôÔ∏è Fonksiyonalite: ${this.results.functionality.percentage}% (${this.results.functionality.implemented}/${this.results.functionality.total})`);
    console.log(`üöÄ Production: ${this.results.production.readiness}% (${this.results.production.readyFeatures}/${this.results.production.totalChecks})`);
    console.log(`üîí G√ºvenlik: ${this.results.security.score}% (${this.results.security.secureFeatures}/${this.results.security.totalChecks})`);
    console.log(`‚ö° Performans: ${this.results.performance.score}% (${this.results.performance.optimizedFeatures}/${this.results.performance.totalChecks})`);
    console.log(`üåê Deployment: ${this.results.deployment.readiness}% (${this.results.deployment.readyFeatures}/${this.results.deployment.totalChecks})`);

    console.log('\nüéØ DURUM DEƒûERLENDƒ∞RMESƒ∞:');
    this.printStatusAssessment(overallScore);

    console.log('\nüí° √ñNERƒ∞LER:');
    this.printRecommendations();

    console.log('\nüèÅ ANALƒ∞Z TAMAMLANDI!');
    console.log(`‚è±Ô∏è S√ºre: ${duration}ms`);
    console.log(`üìÖ Tarih: ${new Date().toLocaleString('tr-TR')}`);
    console.log('‚ïê'.repeat(60));
  }

  getScoreStatus(score) {
    if (score >= 95) return 'üèÜ M√ºkemmel - Production i√ßin hazƒ±r!';
    if (score >= 90) return 'ü•á √áok ƒ∞yi - Minor iyile≈ütirmeler';
    if (score >= 80) return 'ü•à ƒ∞yi - Birka√ß geli≈ütirme gerekli';
    if (score >= 70) return 'ü•â Orta - √ñnemli iyile≈ütirmeler';
    if (score >= 60) return '‚ö†Ô∏è Zayƒ±f - Major geli≈ütirmeler gerekli';
    return 'üö® Kritik - Significant development required';
  }

  printStatusAssessment(score) {
    if (score >= 90) {
      console.log('üü¢ Sƒ∞STEM PRODUCTION READY!');
      console.log('‚Ä¢ GitHub\'a push edilebilir');
      console.log('‚Ä¢ Render\'da deploy edilebilir');
      console.log('‚Ä¢ UptimeRobot ile monitor edilebilir');
    } else if (score >= 80) {
      console.log('üü° Sƒ∞STEM NEREDEYSE HAZIR');
      console.log('‚Ä¢ K√º√ß√ºk d√ºzeltmeler yapƒ±lmalƒ±');
      console.log('‚Ä¢ Test environment\'da √ßalƒ±≈ütƒ±rƒ±labilir');
    } else {
      console.log('üî¥ Sƒ∞STEM HAZIR DEƒûƒ∞L');
      console.log('‚Ä¢ Kritik sorunlar giderilmeli');
      console.log('‚Ä¢ Geli≈ütirme devam etmeli');
    }
  }

  printRecommendations() {
    const recommendations = [];
    
    if (this.results.fileStructure.completeness < 100) {
      recommendations.push(`Eksik dosyalarƒ± tamamla: ${this.results.fileStructure.missing.slice(0, 3).join(', ')}`);
    }
    
    if (this.results.codeQuality.utf8Issues > 0) {
      recommendations.push('UTF-8 encoding sorunlarƒ±nƒ± √ß√∂z');
    }
    
    if (this.results.security.score < 85) {
      recommendations.push('G√ºvenlik √∂nlemlerini g√º√ßlendir');
    }
    
    if (this.results.performance.score < 80) {
      recommendations.push('Performans optimizasyonlarƒ± yap');
    }
    
    if (recommendations.length === 0) {
      recommendations.push('Sistem optimize edilmi≈ü durumda! üéâ');
    }
    
    recommendations.forEach(rec => console.log(`üí° ${rec}`));
  }
}

// CLI Usage
if (require.main === module) {
  const analyzer = new SystemAnalyzer();
  analyzer.runCompleteAnalysis().catch(console.error);
}

module.exports = SystemAnalyzer;
